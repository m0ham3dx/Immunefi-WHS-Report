<p align="center">
<a href="https://twitter.com/m0ham3dxx" target="_blank">
<img src = "https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgithub.com%2Fm0ham3dx%2FImmunefi-WHS-Report&count_bg=%23270082&title_bg=%23570530&icon=snapchat.svg&icon_color=%2304FF7B&title=n00bs&edge_flat=false">
</a>
</p>

# ðŸŸ  METHODOLOGIES 

<p align="center">
<a href="https://twitter.com/m0ham3dxx" target="_blank">
<img src="./img/reactor.gif">
</a>
</p>

This section will be regarding my general approach and related matters. 

> ðŸ‘‰ I have made some mention of the various tooling which are in use. These however can be considered adequate, they are purely my personal choices

# ðŸ§¡ Game Plan 

When I came into the `web3` security space, I was already researching this area with the plan of doing a startup. So I was constantly familiarizing myself with *blockchain* technologies and focussing on the devleopment aspect. Prior to that I was what you call a "security enthusiast" in the web2 (traditional centralized computing) domain. 

The `web3` space during that period was under constant exploitation, with astronomical sums being [lost.](https://web3isgoinggreat.com/) This was the impetus that led me down this rabbit hole

```mermaid
%%{init: {'theme':'dark'}}%%
flowchart TD
	A[<font size=22px> WHS <br> plan <br>]-->B(Learn<br>Fundamentals )
	
	A --> C(Attempt<br>CTFS)
	A --> D(Attempt<br>Bounties)
	
	B --> b1(Solidity<br>Fundamentals)

	B --> b2(Javascript<br>Fundamentals)
	
	C --> c1(Ongoing<br>On my<br>Github Repo)
				click c1 href "https://github.com/m0ham3dx/mxweb3ctfs" "M0ham3dx Github Repo" _blank
	
	D --> d1(Attempts on programs <br> To be documented <br> in relevant week report)

```

The above map was my own take on this matter after researching several learning paths. The good news was that the area of `web3 Security` was already heavily under investigation. This led to a wide variety of information which was available online. My primary research reference was [w3bs3c - Compilation of Web3 Security](https://www.w3bs3c.com/). 


# ðŸ§¡ Constantly Evolving Methodology 

The following methodology was arrived at after researching existing `web2` & `web3` methodologies. They are derived from documentation detailed practical debugging or code.  

```mermaid
%%{init: {'theme':'dark'}}%%
flowchart TD

    %% Header box
    MX(<font size=20px>m0ham3d<br>WHS BB Methodology) o--oA 
            style MX stroke-width:0px

    %% Phase 1 
        A[My<br>Methodology<br>Evolving]-->B(Phase 1 <br> Recon)
        B --> B1(Lookover Immunefi BB <br> Glance at main wesbite)
        B --Prevent<br>Examining known<br>Problems --> B2(Review<br>Existing<br>Audit Reports )

    %% Phase 2 
        A --> C(Phase 2<br>Automated<br>Testing)
        C --> C1(Solidity<br>)
            C1 --> C11(Slither )
            C1 --> C12(Mythril )
        C --> C2(Rust<br>)
            C2 --Rust Code<br> Being Learnt  --> C21( -Soteria<br> -CargoFuzz )

    %% Phase 3 Identify Vulnerbale Function Boxes 
        A --> D(Phase 3<br> Identify Functions<br> prone to being exploited )
            D --Automated --> D1(Solidity<br>Metrics )
            D --Manual --> D2(Read<br>Contract )

    %% Phase 4 - Threat Modeling 
        A --> E(Phase 4<br>Threat<br>Modelling )
            E --> E1(Examine previous<br>vulnerabilities <br> based on type<br>of contract )
            E1 --Classic<br>Threat Hunting<br>Method <br>--> E2{{1. Identify Entry Points <br> 2. Determine Threat Scenarios <br> 3. Determine Actors <br> 4.  }}
                    click E href "https://www.w3bs3c.com/list?recordId=recWW7im5o9S9uaDF" _blank

    %% Phase 5 Fuzzing 
        A --> F(Phase 5<br>Fuzzing )
            F --> F1(Echidna<br>)
            F --> F2(Foundry<br>)
                        click F2 href "https://book.getfoundry.sh/forge/fuzz-testing.html" _blank

    %% Phase 6 
        A --> G(Phase 6 <br> POC )
            subgraph Submission
                G --> G1(Write Unit Tests<br>to prove POC )
                G1 --> G2(Foundry )
                        click G2 href "https://book.getfoundry.sh/forge/writing-tests.html" _blank
                G1 --> G3(Brownie )
            end

    %% Phase 7 
        A---H(Phase 7 <br> Fix  )
            H-->H1(Participate with project <br> for recommending fix )
```
The summary of the above diagram is as follows 

1. **Phase 1 - Recon** - Which means gathering information about your target, this phase is considered to be the most important phase in this process, poor recon leads to inability of identify bugs. 

2. **Phase 2 - Automated Testing** - This is often used for baselining. Usually most projects already use automated testing in their testine pipelines. However as the code base gets constantly updated, the <u>probability</u> of logical errors go up, and <i>automated tooling</i> is a fast way (albeit not the most precise way, due to the presence of false positives).
 
 3. **Phase 3 - Exploitable Functions** - This step involves functions that are prone to being exploited , some eg: of arbitray functions - 
    1. `depositFunds()` - For depoisiting crypto in
    2. `withdrawFunds()` - For withdrawing crypto
   

> ðŸ‘‰ [Smart Contract Weakness Classification Registry (SCWCR)](https://github.com/SmartContractSecurity/SWC-registry) - A repository of known vulnerability issues in Ethereum

4. **Phase 4 - Threat Modelling** - Once vulnerable code has been identified, the next step to assess the risk of those functions in simulated conditions. As a good starting point, it was recommended to read about past attacks, that given technical details on how the exploit occurred.

> ðŸ‘‰ [The three core levels of thinking for a Bug Hunter](https://twitter.com/joranhonig/status/1546837558730047488?s=20&t=hBTDVECNHoB0a0WLTXRrJQ) - Excellent tweet threat on threat modelling methodology in general.

5. **Phase 5 - Fuzzing** - Accomplished by tooling that can rapidly input a wide range of inputs to assess the behavior of a function. *Note - This step is not necessarily agreed upon, but in my opinion is a fast way to assess the risk of a bug which has been identified*

6. **Phase 6 - POC** - A critical step in making the project understand the impact of the finding. This step is often overlooked either due to negligence or lack of technical ability to write a greate **POC**. The latter issue can be rectified by learning how existing POC's for findings have ben written. This step is crucial to determing whether the finding is worth of a reward.


# ðŸ§¡ My Learning Map 

The following is the my current learning map. The sources mentioned might be dated since this field is constantly evolving. I recommend that this learning map be taken as a starting point for your journey to build upon

```mermaid
%%{init: {'theme':'dark'}}%%
%% Concepts Upskilling Path 
flowchart LR
%% Rigth Side Node
	A{{m0ham3dx<br>Upskill<br>Pathway }} o--o B(Learn<br>Solidity )
 
%% Learn solidity Node
	B --- B0(Youtube)
	B0 --- B001(FreeCodeCamp<br>16 HR tutorial )
	B0 --- B002(Immunefi)
	B0 --- B003(Soldity<br>by<br>example )
	B --- B01(Web)
	B01 --- B011(Crypto<br>Zombies )
	B01 --- B012(Immunefi<br>Blog )
	B01 --- B013(Immunefi<br>Twitter<br>Posts )

%% Soldity Testing Node
	A o--o B1(Solidity<br>Testing )
	B1 --- B11(Eth<br>Brownie )
	B1 --- B12(Foundry )

%% Solidity Fuzzing Node
	A o--o B3(Solidity<br>Fuzzing )
	B3 --- B30(Manticore)
	B3 --- B31(Echidna)
	B3 --- B32(Foundry)
	
%% Left Side Node
	C2(SC<br>Scanning<br>Tooling ) o--o A
	C21(Slither ) --- C2
	C22(Mythril ) --- C2
	
%% Left Side Note
	C3(Other<br>Langs ) o--o A
	C31(JS<br>Basic ) --- C3
	C32(Rust<br>Basic ) --- C3
```

## Map Core Camponents 

1. Language Upskilling - The most commonly used development languages which are used are - 
   1. [Solidity- Target -> EVM](https://docs.soliditylang.org/en/v0.8.15/) - The large number of projects all are on the Ethreum Chain. 
   2. [Rust](https://doc.rust-lang.org/rust-by-example/) -> [Solana](https://solana.com/nl/developers)/[Near](https://near.org/developers/) - Rust in addition to being a popular language for general development, since it is the closest to the `C` language, is also used for blockchain apps development.
   3. Javascript - Soldity is close to `javascript` and tests written for solidity dapps are in `javascriptt` which are used by the [Hardhat - Popular Development Environment for Dapp Development](https://hardhat.org/). However at the time of writing this report, there is a much faster Solidity Development Environment which has been written entirely in rust from the ground up. Its name is [Foundry](https://github.com/foundry-rs/foundry)
   4. Pythonic Languages - [Vyper](https://vyper.readthedocs.io/en/stable/) , [Brownie](https://eth-brownie.readthedocs.io/en/stable/) & [Apeworks](https://www.apeworx.io/) are all pyhtonic languages, which are used for dapp dapp development and testing. Perfect for all the <u><i>pythonista's</u></i>
   
    > ðŸ‘‰ [Plot showing languages used for blockchain development](https://defillama.com/languages) - Current blockchain learning map


2. Tooling - There are are variety of tools that make the testing of smart contract code a whole lot easier. They can be grouped into the following categories. Some tools have multiple functions. These are just the ones which I use and/or have come across.
   1. Transactions Analyzers
      1. [Eththx Transaction Decoders](https://ethtx.info/)
      2. [Tenderly Dashboard](https://dashboard.tenderly.co/explorer?utm_source=homepage)
      3. [Dedaub](https://www.dedaub.com/)
   2. Automated Exploit Scanners
      1. [Slither](https://github.com/crytic/slither)
      2. [Mythxril](https://github.com/ConsenSys/mythril)
   3. Fast Development Environments 
      1. [Foundry](https://github.com/foundry-rs/foundry)
      2. [Tenderly](https://tenderly.co/)
   4. Fuzzers
      1. [Echidna](https://github.com/crytic/echidna)
      2. [Foundry](https://github.com/foundry-rs)

> ðŸ‘‰ More tools can be founder here - [W3bS3C - Auditing and Development Tools](https://www.w3bs3c.com/tools)

3. CTF's - There exists a variety of [CTF's](https://www.w3bs3c.com/ctfs) for `web3`. I am actively attempting on some of them [HERE.](https://github.com/m0ham3dx/mxweb3ctfs)

> ðŸ‘‰ As of writing this report the second version of the famous `Paradigm CTF`, has a second version [HERE](https://ctf.paradigm.xyz/)


